createStore.d.ts

declare module 'respond-framework' {
  interface Options {
    useSpread?: boolean
  }

  type foo = (options: Options) => Options

  function createStore(options: Options): foo

  export {
    createStore
  }
}



NEW UI WORK:
- naked component functions
- widgets: Box, Row, Button, Dropdown, Switch, Checkbox, Radio, Card
- components: Modal, Drawer, TabBar, ListView, Input, Radio, Pressable, Link
- Docs website, Login, Recipes (plugins, modules)[multi tab recipe like vs code], Feed, Users



#ErrorBoundary only works with top level Flash state
#"babel": "NODE_ENV=development WEB=true babel-core ./foo.js",

"start": "NODE_ENV=development BUNDLER=webpack babel-watch --watch webpack --exclude ./respond --exclude ./controllers --exclude ./models --exclude ./utils --exclude ./config.js --exclude ./config.client.js --exclude ./config.server.js --exclude ./permissions.js --exclude ./testing  --exclude ./seed  --exclude ./device  --exclude ./helpers  --exclude ./constants  --exclude ./apis  --exclude ./monkey  --exclude ./validation  --exclude ./ --exclude ./games ./server/index.dev.js",

#from + 's'
#aggregateCount
#turn collection getter into method
#replay tools in production
#set replays defaultProductionValue in production
#import recursiveReadSync from 'recursive-readdir-sync'
#duplicating find into _find
#make ReplayTools rows have better press events on native
#make db/index.mock.js utilize create() method exactly like production version
#import db circurlarly from createdatabase



#PUT ENTIRE STORE IN VALTIO
#- lazy valtio
#- put all store options into valtio state
#-wrapModelProxy automatically to docs in state

#make sure restorSession isn't called for regular sessions
#put skip, limit, sort, and proj in options object

#final solution to simplify Code widget

#make tests stop snapping irrelevant areas (eg Home, Drawer)





isNamespace
use constants like kind.navigation, namespace.website
dont hide _namespace, _type in state (only in actions)





/**
 * put all of store + events in proxy state
 * replace 3 args with 2 args
 * refactor createStore
 * make respond support modular replacement of all key pillars within createStore
 * splitting + ssr
 */

#- prototypes or static methods
#- parents for selector props
#- automatically apply models

#- reactive functions/getters anywhere in state


#- create new models client side
#- reviver transforms models using __type
#- __type is deleted before saving!
#- fetch is passed modulePath + models and applies them in reviver

#- selectors are attached to initial state
#- _state is set in proxy getter
#- selector props' parent is bound to this in createInitialState 

#- make findOne etc just return doc
#- Autocomplete can just deal with return, as fetch wraps model already


#- snaps are making _state proxy, and is therefore not recursively applying snapProxy along with recursive selectors
#- really we need a better mechanism for accessing _state in models, or to get rid of it

#- overridable getters

#- selectors can be set in initialState, prop selectors can be passed via ininitialState rehydration mechanism
#- need to make sure prop selectors are tracked




#- put events in state
#- change useSnapshot to target just the module's proxy - make sure parent is tracked for props
#- make useSnapshot find events in state

#- transfer selectors to initialState
#- resolve models which cant have duplicate keys in both proto + this
#- remove _state from model methods

#- newly created models need an api to automatically apply __type (eg: db.round.create())

#- change selectors to use `this`
#- selectorsD -> selectors
#- make all objects created with __type


#- pass tests

#- make test events work correctly
#- refresh weakMaps cache correctly
#- pass handicaps test

#- put events in state
#- make useRespond get events from state

#- make snaps save in state as prevState
#- put the rest of things in state

#- refactor transform/recursion to make use of new structure
#- make entire module be initial state


- remove findOne, findOnePlayer, etc -- problem is they also handle the case where u pass a pojo

- children can specify their own props, and hi-jack access to parent state??




#revisit moduleKeys
#hydrated parentState
#props with new format (eg reducers in state)
#reducers

#access raw non-reactive state in component state

#reducer props from parent, using Map, and then use selector in its place
#for both events + reducer props support new definitions, which are placed on the parent


#manual selectors
#grand parent reducer accessed by selector
#fresh reducer in child

#fresh reducer copied to parent, then automatic selector created in child
#existing reducer automatically turned into selectors based on parent reducer discovery from Map

#access grand parent reducer with function that returns reducers


#access raw non-reactive state in component state

#hmr/replay createStore(topModuleOriginal)
#createController/clientDatabase

#combine recursive createStore code into a single function


#new approach to accessing modulePath in dbProxy
#controllers shouldn't be duplicated if same config as parent (like events)
#createControllerTree needs finishing

#combine things into options etc

#db props

#move misc things into recursion: pathSpecs, plugins, modulePaths, moduleKeys
#getSessionState needs protos hydrated

#devtools
#finalize cleaning topModule stuff at top of createStore, address topReplays etc stuff

#remove initialState
#ad hoc event props simply created in module
#nested reducer props


#selecting module from replayTools when module doesn't have its own controllers (previous nested setting)
 #crawl back up to non-existent parents to look for db/replays/options/cookies

#module selector in replayTools: Top option



#wind both propEvents + events through createEventsForModule, cache non prop

#extract reducers as any 2-3 arg functions in state, extract 0-1 arg functions into selectors
#immutable so replayEvents/reload works correctly


#recurse merge // createSeed, configReplays
#...rest needs getOwnPropertyDescriptors, getters in state, createModels




#getSessionState handling of recording nested selectors
#getSessionState handling of knowing which module model prototypes came from

#createEvents: save event in store.eventsByType
#createInitialState: save models in store.modelsByModulePath

Model: save modulePath in function(doc, modulePath)

#fetch reviver: pass modulePath 
#getSession reviver: new store.modelsByModulePath[doc.__modulePath][v.__type](v)


revive ssr models (posts)

immutability:
reducers
selectors
initial state


#initial state + props.state may have models that need hydration
#so like getSessionState, it would be nice to do in a second pass

#prop extraction into propReducers, propSelectors, propDefaultStateDescriptors
#hydration state is handled like getSessionState as being structured like completed state tree

#models in standard state
#cloneDeep


#const event = eventsByType[type] ?? 
#namespaces may match a module, conflicting in eventsByType

prevState needs to exist on each module

consolidate api methods in createStore
make all tools replacable by user
code split module
use symbol for _parent

replayToolsState can possibly piggy back on getSessionState

db.create should probably create IDs client side